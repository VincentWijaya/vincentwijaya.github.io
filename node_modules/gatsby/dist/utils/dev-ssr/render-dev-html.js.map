{"version":3,"sources":["../../../src/utils/dev-ssr/render-dev-html.ts"],"names":["startWorker","newWorker","JestWorker","require","resolve","exposedMethods","numWorkers","forkOptions","silent","warmup","worker","initDevWorkerPool","changeCount","restartWorker","htmlComponentRendererPath","oldWorker","end","deleteModuleCache","searchFileForString","substring","filePath","Promise","chunkRegex","RegExp","stream","fs","createReadStream","found","on","d","test","toString","close","ensurePathComponentInSSRBundle","page","directory","report","panic","componentChunkName","readAttempts","searchForStringInterval","setInterval","clearInterval","renderDevHTML","path","store","reject","pageObj","getState","isClientOnlyPage","matchPath","boundActionCreators","createServerVisitedPage","createClientVisitedPage","htmlString","renderHTML","componentPath","component","error"],"mappings":"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","sourcesContent":["import JestWorker from \"jest-worker\"\nimport fs from \"fs-extra\"\nimport { joinPath } from \"gatsby-core-utils\"\nimport report from \"gatsby-cli/lib/reporter\"\n\nimport { startListener } from \"../../bootstrap/requires-writer\"\nimport { findPageByPath } from \"../find-page-by-path\"\nimport { getPageData as getPageDataExperimental } from \"../get-page-data\"\n\nconst startWorker = (): any => {\n  const newWorker = new JestWorker(require.resolve(`./render-dev-html-child`), {\n    exposedMethods: [`renderHTML`, `deleteModuleCache`, `warmup`],\n    numWorkers: 1,\n    forkOptions: { silent: false },\n  })\n\n  // jest-worker is lazy with forking but we want to fork immediately so the user\n  // doesn't have to wait.\n  // @ts-ignore\n  newWorker.warmup()\n\n  return newWorker\n}\n\nlet worker\nexport const initDevWorkerPool = (): void => {\n  worker = startWorker()\n}\n\nlet changeCount = 0\nexport const restartWorker = (htmlComponentRendererPath): void => {\n  changeCount += 1\n  // Forking is expensive — each time we re-require the outputted webpack\n  // file, memory grows ~10 mb — 25 regenerations means ~250mb which seems\n  // like an accepatable amount of memory to grow before we reclaim it\n  // by rebooting the worker process.\n  if (changeCount > 25) {\n    const oldWorker = worker\n    const newWorker = startWorker()\n    worker = newWorker\n    oldWorker.end()\n    changeCount = 0\n  } else {\n    worker.deleteModuleCache(htmlComponentRendererPath)\n  }\n}\n\nconst searchFileForString = (substring, filePath): Promise<boolean> =>\n  new Promise(resolve => {\n    // See if the chunk is in the newComponents array (not the notVisited).\n    const chunkRegex = RegExp(`exports.ssrComponents.*${substring}.*}`, `gs`)\n    const stream = fs.createReadStream(filePath)\n    let found = false\n    stream.on(`data`, function (d) {\n      if (chunkRegex.test(d.toString())) {\n        found = true\n        stream.close()\n        resolve(found)\n      }\n    })\n    stream.on(`error`, function () {\n      resolve(found)\n    })\n    stream.on(`close`, function () {\n      resolve(found)\n    })\n  })\n\nconst ensurePathComponentInSSRBundle = async (\n  page,\n  directory\n): Promise<any> => {\n  // This shouldn't happen.\n  if (!page) {\n    report.panic(`page not found`, page)\n  }\n\n  // Now check if it's written to public/render-page.js\n  const htmlComponentRendererPath = joinPath(directory, `public/render-page.js`)\n  // This search takes 1-10ms\n  // We do it as there can be a race conditions where two pages\n  // are requested at the same time which means that both are told render-page.js\n  // has changed when the first page is complete meaning the second\n  // page's component won't be in the render meaning its SSR will fail.\n  let found = await searchFileForString(\n    page.componentChunkName,\n    htmlComponentRendererPath\n  )\n\n  if (!found) {\n    await new Promise(resolve => {\n      let readAttempts = 0\n      const searchForStringInterval = setInterval(async () => {\n        readAttempts += 1\n        found = await searchFileForString(\n          page.componentChunkName,\n          htmlComponentRendererPath\n        )\n        if (found || readAttempts === 5) {\n          clearInterval(searchForStringInterval)\n          resolve()\n        }\n      }, 300)\n    })\n  }\n\n  return found\n}\n\nexport const renderDevHTML = ({\n  path,\n  page,\n  store,\n  htmlComponentRendererPath,\n  directory,\n}): Promise<string> =>\n  new Promise(async (resolve, reject) => {\n    startListener()\n    let pageObj\n    if (!page) {\n      pageObj = findPageByPath(store.getState(), path)\n    } else {\n      pageObj = page\n    }\n\n    let isClientOnlyPage = false\n    if (pageObj.matchPath) {\n      isClientOnlyPage = true\n    }\n\n    const { boundActionCreators } = require(`../../redux/actions`)\n    const {\n      createServerVisitedPage,\n      createClientVisitedPage,\n    } = boundActionCreators\n    // Record this page was requested. This will kick off adding its page\n    // component to the ssr bundle (if that's not already happened)\n    createServerVisitedPage(pageObj.componentChunkName)\n\n    // We'll also get a head start on compiling the client code (this\n    // call has no effect if the page component is already in the client bundle).\n    createClientVisitedPage(pageObj.componentChunkName)\n\n    // Ensure the query has been run and written out.\n    try {\n      await getPageDataExperimental(pageObj.path)\n    } catch {\n      // If we can't get the page, it was probably deleted recently\n      // so let's just do a 404 page.\n      return reject(`404 page`)\n    }\n\n    // Wait for public/render-page.js to update w/ the page component.\n    await ensurePathComponentInSSRBundle(pageObj, directory)\n\n    // Ensure the query has been run and written out.\n    await getPageDataExperimental(pageObj.path)\n\n    try {\n      const htmlString = await worker.renderHTML({\n        path,\n        componentPath: pageObj.component,\n        htmlComponentRendererPath,\n        directory,\n        isClientOnlyPage,\n      })\n      return resolve(htmlString)\n    } catch (error) {\n      return reject(error)\n    }\n  })\n"],"file":"render-dev-html.js"}